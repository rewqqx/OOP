# Суть

Паттерн Decorator - это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

# Что решает

1. Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях.
2. Основой библиотеки является класс Notifier с методом send, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.
3. В один момент только email стало не хватать и клиенты захотели получать письма по фейсбуку, слаку или смс, а кто-то вообще по комбинациям этих вариантов
4. Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.
5. Наследование — это первое, что приходит в голову, когда нужно "расширить класс", но:
6. 1. Он статичен. Чтобы изменить поведение существующего объекта, нужно создать новый с другим подклассом.
7. 2. Он не разрешает наследовать поведение нескольких классов одновременно. Поэтому приходится создавать множество подклассов-комбинаций.
8. Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией . Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение.
9. Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения. Последняя обёртка и будет тем объектом, с которым будет работать клиент. Все обёртки имеют такой же интерфейс, как и базовый класс

# Структура и пример кода

Примером использования паттерна может быть добавление новых свойств, методов или поведения существующего объекта, чтобы сделать его более гибким и функциональным. Например, мы можем добавить новый механизм аутентификации к системе без необходимости изменения основного класса системы аутентификации.

Для реализации паттерна Decorator мы создаем два основных класса: Component и Decorator. Component представляет базовый объект, который мы хотим изменить, а Decorator представляет класс, который наследуется от Component и предоставляет новые возможности.

```py
class Component:
    def operation(self):
        pass

class ConcreteComponent(Component):
    def operation(self):
        return "Concrete component"

class Decorator(Component):
    def __init__(self, component):
        self.component = component

    def operation(self):
        return self.component.operation()

class ConcreteDecoratorA(Decorator):
    def operation(self):
        return "Concrete decorator A"

class ConcreteDecoratorB(Decorator):
    def operation(self):
        return "Concrete decorator B"
```

В этом примере класс Component представляет базовый объект, который мы хотим изменить, а класс ConcreteComponent представляет сам объект. Класс Decorator определяет базовые возможности декоратора и использует композицию для добавления новой функциональности объекту. Классы ConcreteDecoratorA и ConcreteDecoratorB представляют конкретные декораторы, которые добавляют дополнительные возможности объекту.

Для использования паттерна Decorator мы создаем декораторы, которые добавляют нужную функциональность к объекту, и затем применяем эти декораторы к объекту, добавляя новые свойства и методы при необходимости. Одно из главных преимуществ паттерна Decorator заключается в том, что он позволяет добавлять новые функциональные возможности объекту без изменения его основного класса, что обеспечивает гибкость и расширяемость кода.

# Когда применять

1.  Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.
    Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.

2.  Когда нельзя расширить обязанности объекта с помощью наследования.
    Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью Декоратора.

# Плюсы и минусы

Плюсы

1. Большая гибкость, чем у наследования.
2. Позволяет добавлять обязанности на лету.
3. Можно добавлять несколько новых обязанностей сразу.
4. Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

Минус

1. Трудно конфигурировать многократно обёрнутые объекты.
2. Обилие крошечных классов

# Отношения с другими паттернами

1. Адаптер меняет интерфейс существующего объекта. Декоратор улучшает другой объект без изменения его интерфейса. Причём Декоратор поддерживает рекурсивную вложенность, чего не скажешь об Адаптере. На практике Декоратор расширяет интерфейс, а Адаптер предоставляет классу альтернативный интерфейс
2. Декоратор и Заместитель имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что Заместитель сам управляет жизнью сервисного объекта, а обёртывание Декораторов контролируется клиентом.
