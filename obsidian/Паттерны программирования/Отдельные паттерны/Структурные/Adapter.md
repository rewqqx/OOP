# Суть
**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

# Что решает
1. Позволяет работать с объектами, чьи интерфейсы несовместимы с нашим приложением
   
Разрешим ситуацию, когда необходимо использовать сторонний компонент в приложении, но интерфейс компонента не соответствует интерфейсу вашего приложения. Вместо того, чтобы изменять код стороннего компонента или код вашего приложения, мы можем использовать паттерн Adapter.

Примером использования паттерна Adapter может быть работа с различными API, которые получают данные в разных форматах. Например, если один API возвращает данные в формате JSON, а другой возвращает данные в формате XML, мы можем использовать Adapter для преобразования данных из одного формата в другой.

# Структура и пример кода

Для реализации паттерна Adapter мы создаем адаптерный класс, который обеспечивает интерфейс, совместимый с интерфейсом целевого класса. Затем мы используем этот адаптерный класс для работы с данными, которые поступают из внешнего источника.

Пример реализации паттерна Adapter на Python:

```py
class Target:
    def request(self):
        pass
            
class Adaptee:
    def special_request(self):
        pass
            
class Adapter(Target):
    def __init__(self, adaptee):
        self.adaptee = adaptee
            
    def request(self):
        self.adaptee.special_request()
```

В этом примере класс Adapter наследуется от класса Target и использует объект класса Adaptee для выполнения операций. Адаптерный класс принимает в качестве аргумента класс Adaptee, с несовместимым интерфейсом.

Адаптерный класс переопределяет метод request() класса Target и передает соответствующий запрос на объект Adaptee с помощью его метода special_request().

Паттерн Adapter позволяет работать с объектами, чьи интерфейсы несовместимы с нашим приложением. Этот шаблон снижает связность компонентов, уменьшает количество повторного кода и позволяет изменять реализацию одной или обеих сторон без необходимости изменения другой стороны.

# Когда применять
1. Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
2. Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.
# Плюсы и минусы
Плюсы
1.  Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
Минусы
1. Усложняет код программы из-за введения дополнительных классов.
# Отношения с другими паттернами
1. Адаптер меняет интерфейс существующего объекта. Декоратор улучшает другой объект без изменения его интерфейса. Причём Декоратор поддерживает рекурсивную вложенность, чего не скажешь об Адаптере.
2. Фасад задаёт новый интерфейс, тогда как Адаптер повторно использует старый. Адаптер оборачивает только один класс, а Фасад оборачивает целую подсистему. Кроме того, Адаптер позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.