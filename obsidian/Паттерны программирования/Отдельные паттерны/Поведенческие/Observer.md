# Суть

Паттерн Observer - это шаблон, который определяет зависимость между объектами таким образом, чтобы при изменении состояния одного объекта автоматически происходили изменения его зависимостей.

# Что решает

Представьте, что вы имеете два объекта: Покупатель и Магазин. В магазин вот-вот должны завезти новый товар, который интересен покупателю.
Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку тратя своё драгоценное время.
С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар специфический, и не всем он нужен.
Давайте называть Издателями те объекты, которые содержат важное или интересное для других состояние. Остальные объекты, которые хотят отслеживать изменения этого состояния, назовём Подписчиками.
Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки самостоятельно. Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.
Теперь самое интересное. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков.
Издателю безразлично, какой класс будет иметь тот или иной подписчик, так как все они должны следовать общему интерфейсу и иметь единый метод оповещения.

# Структура и пример кода

Для реализации паттерна Observer мы создаем два основных класса: Subject и Observer. Subject представляет наблюдаемый объект, который оповещает своих наблюдателей об изменении состояния. Observer представляет наблюдателя, который получает оповещения и реагирует на изменения состояния наблюдаемого объекта.

```py
class Subject:
    def __init__(self):
        self.observers = []
        self._state = None

    def attach(self, observer):
        if observer not in self.observers:
            self.observers.append(observer)

    def detach(self, observer):
        try:
            self.observers.remove(observer)
        except ValueError:
            pass

    def notify(self):
        for observer in self.observers:
            observer.update(self)

    def get_state(self):
        return self._state

    def set_state(self, state):
        self._state = state
        self.notify()

class Observer:
    def update(self, subject):
        pass

class ConcreteObserver(Observer):
    def update(self, subject):
        self.state = subject.get_state()
```

В этом примере класс Subject предоставляет методы для подписки и отписки от оповещений, а также метод notify(), который оповещает всех своих наблюдателей об изменении состояния. Класс Observer представляет абстрактный объект, который будет получать оповещения, а класс ConcreteObserver представляет конкретный объект, который будет реагировать на изменения состояния.

# Когда применять

Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.
Паттерн Наблюдатель позволяет любому объекту с интерфейсом подписчика зарегистрироваться на получение оповещений о событиях, происходящих в объектах-издателях.

Когда одни объекты должны наблюдать за другими, но только в определённых случаях.
Издатели ведут динамические списки. Все наблюдатели могут подписываться или отписываться от получения оповещений прямо во время выполнения программы.

# Плюсы и минусы

Плюсы

1. Издатели не зависят от конкретных классов подписчиков и наоборот.
2. Вы можете подписывать и отписывать получателей на лету.
3. Реализует принцип открытости/закрытости.

Минус

1. Подписчики оповещаются в случайном порядке.

# Отношения с другими паттернами

1. Команда, Посредник и Наблюдатель показывают различные способы работы отправителей запросов с их получателями:

Команда устанавливает косвенную одностороннюю связь от отправителей к получателям.
Посредник убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
Наблюдатель передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.

2. Разница между Посредником и Наблюдателем не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.
   Цель Посредника — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель Наблюдателя — обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.

Еще популярна реализация Посредника при помощи Наблюдателя. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.
